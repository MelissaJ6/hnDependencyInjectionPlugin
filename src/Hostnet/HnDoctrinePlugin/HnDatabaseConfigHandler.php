<?php
namespace Hostnet\HnDoctrinePlugin;

use Doctrine\DBAL\Connection;

use Symfony\Bridge\Doctrine\RegistryInterface;

use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;

use Symfony\Component\Config\Loader\LoaderResolver;

use Symfony\Component\Config\FileLocator;

use Doctrine\Bundle\DoctrineBundle\DependencyInjection\DoctrineExtension;

use Symfony\Component\DependencyInjection\ContainerBuilder;

/**
 * Alternative for the \sfDatabaseConfigHandler, it reads the config in the Symfony2 format
 *
 * To use this find/create the file
 * apps/<app>/config/config_handlers.yml
 *
 * And add:
 * config/databases.yml:
 *   class: Hostnet\HnDoctrinePlugin\HnDatabaseConfigHandler
 *
 * If you want to develop on this class, please note that this is very early in the sf1 initialization
 * So you can't use much more then sfConfig::get('sf_environment');
 */
class HnDatabaseConfigHandler extends \sfYamlConfigHandler
{
  /**
   * @todo make this dynamic
   */
  const DATABASE_ENGINE = 'mysql';

  /**
   * @see sfConfigHandler::execute()
   * @return string PHP code
   */
  public function execute($configFiles)
  {
    $container = new ContainerBuilder();
    $container->registerExtension(new DoctrineExtension());

    $debug = in_array(\sfConfig::get('sf_environment'), array('dev', 'ontw'));
    $container->setParameter('kernel.debug', $debug);

    foreach($configFiles as $file) {
      $this->addResource($container, new \SplFileInfo($file));
    }
    $container->compile();

    if(strpos(SYMFONY_VERSION, '1.1.') === 0) {
      $output = $this->createSymfony11Output($container->get('doctrine'));
    } else if(strpos(SYMFONY_VERSION, '1.3.') === 0 || strpos(SYMFONY_VERSION, '1.4.') === 0) {
      $output = $this->createSymfony14Output($debug, $container->get('doctrine'));
    } else {
      throw new \DomainException('Untested Symfony version '.SYMFONY_VERSION.
          ', but maybe one of the others will work');
    }

    // compile data
    return sprintf("<?php\n".
        "// auto-generated by hnDatabaseConfigHandler\n".
        "// date: %s\n\n%s\n",
        date('Y/m/d H:i:s'), $output);
  }

  private function addResource(ContainerBuilder $container, SplFileInfo $file)
  {
    $locator = new FileLocator($file->getPath());

    $resolver = new LoaderResolver();
    $resolver->addLoader(new YamlFileLoader($container, $locator));

    $resource = 'config-' . \sfConfig::get('sf_environment') . '.yml';
    if(!file_exists($resource)) {
      $resource = 'config.yml';
    }
    $resolver->resolve($resource)->load($resource);
  }

  private function createSymfony11Output(RegistryInterface $registry)
  {
    $output = '';
    foreach($registry->getConnections() as $name => $connection) {
      $config = array('name' => $name, 'dsn' => $this->formatDSN($connection));
      $output .= sprintf('$this->setDatabase("%s", new %s(%s))', $name, $this->getPropelClass(),
          var_export($config, true));
    }
    return $output;
  }

  private function createSymfony14Output($debug, RegistryInterface $registry)
  {
    $output = 'return array(' . PHP_EOL;

    foreach($registry->getConnections() as $name => $connection) {
      /* @var $connection Connection */

      $dsn = sprintf(self::DATABASE_ENGINE . ':dbname=%s;host=%s;port=%s', $connection->getDatabase(),
          $connection->getHost(), $connection->getPort());
      $config = array(
          'classname' => $this->getClassname($debug),
          'dsn' => $dsn,
          'username' => $connection->getUsername(),
          'password' => $connection->getPassword(),
          'persistent' => true,
          'pooling' => true,
          'encoding' => 'utf8',
          'name' => $name
          );
      $output .= sprintf("'%s' => new %s(%s),", $name, $this->getPropelClass(),
          var_export($config, true));
      $output .= PHP_EOL . PHP_EOL;
    }

    $output .= ');';
    return $output;
  }

  /**
   * @todo make "sfPropelDatabase" dynamic, specific for each connection
   * @return string
   */
  private function getPropelClass()
  {
    return 'sfPropelDatabase';
  }

  /**
   * @todo make the mysql bit dynamic
   * @param Connection $connection
   */
  private function formatDSN(Connection $connection)
  {
    return sprintf(self::DATABASE_ENGINE . '://%s:%s@%s:%s/%s',
        $connection->getUsername(),
        $connection->getPassword(),
        $connection->getHost(),
        $connection->getPort(),
        $connection->getDatabase());
  }

  /**
   * @todo make the classname dynamic, and origin from the controller. Hard one..
   * @param unknown_type $debug
   * @return string
   */
  private function getClassname($debug)
  {
    return $debug ? 'DebugPDO' : 'PropelPDO';
  }
}